---
title: "PHW251 Problem Set 2"
author: "Val Stacey"
date: "09/07/2025"
format: html
---



\newpage

### Question 1

Use the function Sys.Date() to get the current date. Save it in your environment.

```{r get_date}

todays_date <- Sys.Date()

```

Use the class() function to see what kind of object your date is, and then use the typeof() function to see how it is stored in R.

```{r class_typeof}

class(todays_date)
typeof(todays_date)

```

Why is your saved object both a Date and a double? HINT: try using as.numeric() on the object and think about what that number means.

```{r}
as.numeric(todays_date)
```


**This paragraph was provided in the .qmd, and I don't have anything to add. I think it answers the question well:**

Dates in R are stored as the number of days before or after 1/1/1970, which is just a number (an integer stored as a double). Because the number came from Sys.Date(), R knows it is not just a normal number and instead displays it as a date.


\newpage

Look up the documentation for the lubridate function `wday` (short for weekday). Load the lubridate library and then pass your date object to `wday()` to get the day of the week *as an abbreviated name* e.g. "Sun" and "Mon". You will need to pass the function a second argument to make this happen. Save the result in your environment.

```{r, eval = FALSE}
?lubridate::wday()
```

`wday` arguments: 

wday(
  x,
  label = FALSE,
  abbr = TRUE,
  week_start = getOption("lubridate.week.start", 7),
  locale = Sys.getlocale("LC_TIME")
)

```{r current_wday, results = FALSE, message = FALSE}
library(lubridate)

current_wday <- lubridate::wday(todays_date, label = TRUE)
current_wday
```

Run this code chunk to save a vector of the seven days of the week. The levels() function returns a vector containing the names of all the levels of a factor.

```{r days_vector}

days <- levels(wday(Sys.Date(), label = TRUE))
days

```

Subset the vector of days to get a vector of *weekdays only* (Mon-Fri). You can pull out values from a vector by using a sequence of positions/indexes inside square brackets (see the lecture "Data Types and Objects in R"). Save the list of weekdays as a new object in your environment.

```{r weekdays}

weekdays <- days[2:6]
weekdays 
```

Is the current day you saved in the current_wday chunk above a weekday? Check using the %in% operator. Also check if the current day is in the days vector.

```{r weekday_test}

current_wday %in% weekdays
current_wday %in% days

```

\newpage

### Question 2

if/else, vector math, logical ops

Run this chunk as-is to load a dataset of [Mauna Loa carbon dioxide records](https://gml.noaa.gov/ccgg/trends/data.html) and plot CO2 levels over time. Importing and plotting data will be covered in an upcoming lecture--the graph is just for context.

```{r co2_import, message = FALSE}
# read in the csv file and save it as a data frame in the environment
co2 <- read.csv(file = "co2_mm_mlo.csv", skip = 51, header = TRUE, row.names = NULL)
# label the columns
colnames(co2) <- c("year","month","date","average","interpolated","trend","ndays", "UNK")
# display the data graphically
plot(x = co2$date, y = co2$average, pch = 20, cex = 0.1, 
     xlab = "Date", ylab = "Average CO2 (ppm)")
# view the last few rows of the data in a table
tail(co2)
```



Before the industrial revolution, the global concentration of carbon dioxide was about [280 parts per million](https://www.climate.gov/news-features/understanding-climate/climate-change-atmospheric-carbon-dioxide). Let's see if we can express CO2 levels over time as a percentage of pre-industrial levels.

Start by extracting the average CO2 level column from the data frame. You can run this chunk as-is, since we haven't covered data frames in detail yet.

```{r co2_extract}

# pull the "average" column out of the data as a vector
avg_co2 <- co2$average
# this is another way to do the exact same thing
avg_co2 <- co2[["average"]]

```


\newpage

Print out the vector avg_co2

```{r co2_print}

avg_co2

```


\newpage

That's a lot of numbers! You wouldn't want to print all that in a report. Use the `summary()` function to get a more useful overview of the range of numbers in that vector.

```{r co2_summary}

summary(avg_co2)

```

Create a vector that expresses the Mauna Loa CO2 levels as a percentage of pre-industrial levels (280 ppm). Save it as a new vector in your environment and print out a summary.

```{r co2_percentage, message = FALSE}

prop_pre_industrial <- 100*(1 - (280/avg_co2))

summary(prop_pre_industrial)

```

Let's say you're publishing a report about climate change and you want to have two versions of it for two different audiences. In one version, you want to report carbon dioxide concentration in parts per million. In the other, you want those numbers as a percentage of pre-industrial levels.

Use if/else blocks to print a summary of Mauna Loa CO2 levels, where the format (ppm or percentage) depends on the logical indicator included in the code chunk below. Make sure you get the expected output when percentage is TRUE, and when percentage is FALSE.

```{r if_else, message = FALSE}

library(dplyr)

co2 <- co2 %>%
  mutate(
    prop_pre_industrial = 100*(1 - (280/average))
  )



print_summary <- function(df, percentage = FALSE) {
  
  if(percentage == FALSE) {
    print("Mauna Loa CO2 concentrations (ppm)")
    summary(df$average)
    
  } else {
    print("Mauna Loa CO2 concentrations (as proportion of pre-industrial level: 280 ppm)")
    summary(df$prop_pre_industrial)
  }
  
}


print_summary(df = co2)

print_summary(df = co2, percentage = TRUE)



```

Look at the date columns in the co2 data frame (you can view the whole table by clicking on "co2" in your environment pane). The "date" column in a decimal date format. Search the web for a function within the lubridate package that can convert a decimal date into the standard date format. Use that function on the vector of decimal dates and print the result. Make sure you set the correct time zone for Hawaii (search the web for the 3-letter abbreviation of that time zone and use that string as the argument)!

```{r time_zone}

co2 <- co2 %>%
  mutate(
    date_POSIXct = date_decimal(date, tz = "HST"),
    date_standard = as_date(date_POSIXct)
  )

co2_dates <- co2 %>%
  select(date, date_POSIXct, date_standard)

head(co2_dates, 4)


```


\newpage

### Question 3

Use a for loop to print out the result of multiplying the numbers 1-10 by 3.

```{r for_loop}

numbers <- 1:10 

for(i in numbers) {
  numbers[i] <- 3 * i
}

print(numbers)


```

\newpage

### Question 4

Use a while loop to do the same thing. It's easy to accidentally create infinite loops; if your chunk takes more than a couple seconds to run, press the red square in the top right corner of the chunk to abort the loop.

```{r while_loop}

numbers <- 1:10 

i <- 1
while (i <= length(numbers)) {
  numbers[i] <- 3 * numbers[i]
  i <- i + 1
}

print(numbers)

```

\newpage

### Question 5

If you haven't created a GitHub account yet, do it now. Paste a link to your GitHub profile below:


https://github.com/EvalstacE


### Question 6

You're working on a group coding project with your classmates that's due soon. After a weekend away from your computer, you open R Studio to start working. What is the first git command you should run?

I would run this in gitbash first: 

* **git fetch origin**

* **git log HEAD..origin/main --oneline**

That will give me a list of my classmates' commits and changes before pulling them in locally. 

Then I would run this in gitbash if I want to make sure my local drive version is up to date with the online version: 

* **git pull origin main**

I could also use the "Pull" directly in RStudio instead of doing that through gitbash. 


### Question 7

You write some new code, save your Qmd file, commit your changes to your local repository, and then go eat dinner. While you're eating, your teammate sends you a message asking where your new code is. What did you forget to do?

**You forgot to "Push"** those changes after committing. 


