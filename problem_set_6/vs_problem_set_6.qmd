---
title: "PHW251 Problem Set 6"
author: "Val Stacey"
date: "11/03/2025"
format:
  html:
    theme: cosmo
    code-overflow: wrap
    self-contained: true
    css: "../www/styles.css"
execute:
  message: false
  warning: false
---

```{r libraries, include = FALSE}
library(readr)
library(readxl)
library(here)
library(tibble)
library(dplyr)
library(tidyr)
library(stringr)
library(janitor)
library(lubridate)
library(kableExtra)
library(knitr)
library(ggplot2)
library(ggthemes)

```



## Part 1

For this part we will work with fictional data comparing the efficacy of two interventions. The interventions took place across several states and cities, with slight variations in dates. The outcome is a continuous variable.

```{r, include=F, echo=F}
df <- read_csv("data/missing_interventions.csv")
```

### Question 1

There's missing data in this data set. Can you identify them? In the next question you will re-code these values to NA.

```{r}
na_sum <- df %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(
    everything(), 
    names_to = "variable", 
    values_to = "na_count"
  ) %>%
  janitor::adorn_totals()
```


|
|

:::: {.columns style="gap: 32px;"}
::: {.column width="70%"}

**1A. How many NAs did you find?** 

* **32** total "NAs" 


**1B. Are there other values you think may count as NA?**

* Yes. I believe that anything coded as **"-999"** is very likely a code for "Unknown" or "NA." Some are also coded as **"-1"** , which likely also indicates an unknown or NA field.

:::
::: {.column width="30%"}

```{r, echo = FALSE}
na_sum %>% 
  kbl(align = "cc", col.names = c("Column Name", "NA Count")) %>%
  column_spec(1, width = "150px",bold = TRUE, extra_css = "font-size: 16px!important;") %>%
  column_spec(2, width = "50px", bold = FALSE, extra_css = "font-size: 16px!important;") %>%
  row_spec(0, bold = TRUE, extra_css = "font-size: 16px!important;") %>%
  row_spec(8, bold = TRUE, background = "#fdf2a6") %>%
  kable_styling(
    bootstrap_options = c("striped", "condensed", "bordered"), 
    position = "center"
    )
```

:::
::::




\newpage

### Question 2

**2A. For the other values you believe may also be NAs, re-code them as NA.**

```{r}
df <- df %>%
  mutate(
    across(
      where(is.character),
      ~ replace(., . %in% c("-999", "-1"), NA_character_)
      )
    )
```


**2B. Print the head() of the dataframe** 

```{r}
head(df, 5)
```



\newpage

### Question 3

Now that we've fixed our NA values, let's address the errors we see with city and state names. Let's fix these entries to have uniform naming where cities are properly capitalized and state abbreviations are in all capital letters. For example, we want to see "San Antonio" and "TX" rather than "san Antonio" and "tx". 

**3A. Use `distinct()` and `pull()` to see all the variations you need to account for.** 

```{r}
states <- df %>%
  distinct(state) %>%
  arrange(state) %>%
  pull(state)

cities <- df %>%
  distinct(city) %>%
  arrange(city) %>%
  pull(city)
```


:::: {.columns style="gap: 24px;"}
::: {.column width="40%"}

**States:**
```{r, echo = FALSE}
paste(states, collapse = ", ")
```

:::
::: {.column width="60%"}

**Cities:**
```{r, echo = FALSE}
paste(cities, collapse = ", ")
```

:::
::::

**3B. Then, use `case_when()` to fix the values.**

We have provided the code to fix the variation for Georgia and Texas using `case_when()`. Expand this code to fix the state abbreviations for California and all the city names.

```{r}
df <- df %>% 
mutate(
  state = case_when(
      state %in% c("TX", "tX", "tx")         ~ "TX",    
      state %in% c("GA", "gA", "ga", "G A")  ~ "GA",
      state %in% c("C A", "CA", "CA_", "ca") ~ "CA",
      TRUE ~ NA_character_
    ), 
  city = case_when(
      city %in% c("austin")                        ~ "Austin",
      city %in% c("iakland", "oakland")            ~ "Oakland",
      city %in% c("San Antonio", "san Antonio")    ~ "San Antonio",      
      city %in% c("Atlanta", "atlAnTa", "atlanta") ~ "Atlanta",
      city %in% c("Hayward", "Haywarf", "hayward") ~ "Hayward",
      TRUE ~ NA_character_    
    )
  )
```

\newpage

### Question 4

**4A. Format the date column into a date format using a lubridate function.**

Ominously, these interventions all occurred on the 25th day of the month.

```{r}
df <- df %>% mutate(date = as.Date(date, format = "%d/%m/%Y"))
df %>% select(state, city, date) %>% slice_head(n=5)
```

\newpage

### Question 5

You may have noticed that some of the cities don't match their state. We can't, at least from our data, distinguish which value is correct (the city or the state). The correct city and state pairings are:

- Atlanta, GA
- Austin, TX
- San Antonio, TX
- Hayward, CA
- Oakland, CA


**5A. Drop the rows with this city/state inconsistency.** 

```{r}
df <- df %>%
  mutate(
    drop_row = case_when(
      state == "GA" &  city == "Atlanta" ~ "keep", 
      state == "TX" &  city %in% c("Austin", "San Antonio") ~ "keep", 
      state == "CA" &  city %in% c("Hayward", "Oakland") ~ "keep", 
      TRUE ~ "drop"
    )
  ) %>%
  filter(drop_row == "keep") %>%
  select(-drop_row)

nrow(df)
```

**5B. Print the unique combinations of city and state that are now in the data frame**  

Use the code below and modify if needed. 

```{r}
unique(df[,c("city", "state")])
```

\newpage

### Question 6

Another issue: our interventions column has missing data. We have two interventions that occurred in these locations:

* Intervention 1: Hayward, Atlanta, San Antonio
* Intervention 2: Oakland, Atlanta, Austin

For all of the cities except Atlanta it's clear what intervention took place. 

**6A. In these clear instances, replace NAs with the appropriate intervention.** 

**6B. For Atlanta, drop the observations with missing intervention data since we cannot determine which intervention occurred.**

```{r}
df <- df %>%
#--6B.
filter(!(city == "Atlanta" & is.na(intervention))) %>%
#--6A.  
mutate(
  intervention =
      as.integer(
        case_when(
          city %in% c("Hayward", "San Antonio") ~ 1,
          city %in% c("Oakland", "Austin") ~ 2, 
          TRUE ~ intervention
        )
      )
    )
```

|

**6C. How many observations did you drop?**

* **2** observations were dropped

---


\newpage

### Question 7

We have a few NAs in the outcome column. Our on-site researchers informed us that when a score of "0" was provided, the data collection team left the cell blank. 

**7A. Re-code the NAs to 0.**

```{r}
df <- df %>% mutate(outcome = if_else(is.na(outcome), 0, outcome))
```

**7B. Use code to confirm that there are no longer any NAs in the outcome column.**
 
```{r}
sum(is.na(df$outcome))
```


### Question 8

**8A Use ggplot to create a box plot comparing the two interventions and their outcome.**  

The outcome is a continuous variable from 0 to 10. You may need to factor one of your variables. Look at the [visualization cheatsheet](https://www.rstudio.com/resources/cheatsheets/) if you don't know the "geom" for creating a boxplot.

```{r}
df <- df %>%
  mutate(intervention = factor(intervention, levels = c(1,2), ordered = TRUE))
```


```{r}
ggplot(df) + 
  geom_boxplot(aes(x = intervention, y = outcome)) + 
  ylab("Outcome") + 
  xlab("Intervention")+
  ggtitle("Distribution of Outcome by Intervention") +
  theme_classic() + 
  theme(
    legend.position = "none",
    plot.title      = element_text(size = 16, hjust = 0.5, margin = margin(b=20)),
    axis.title.y    = element_text(size = 14, margin = margin(r = 10)),
    axis.title.x    = element_text(size = 14, margin = margin(t = 10)),
    axis.text.x     =  element_text(size = 14)
  )
```




\newpage

## Part 2

For this part we will use *fictional* data inspired by research on non-deceptive or open-label placebos. Non-deceptive placebos are placebos but without the deception. Some studies have found suggestions that, despite not being tricked, participants are reporting similar benefits to what they would have with placebos! You can read more here:

[NPR: Is A Placebo A Sham If You Know It's A Fake And It Still Works?](https://www.npr.org/sections/health-shots/2016/10/27/499475288/is-it-still-a-placebo-when-it-works-and-you-know-its-a-placebo)

[Nature Communications: Placebos without deception reduce self-report and neural measures of emotional distress](https://www.nature.com/articles/s41467-020-17654-y)

In this fictional data we conducted an experiment across two university sites to investigate whether non-deceptive placebos decreased self-report pain ratings. There were three groups: control, placebo, and non-deceptive placebo. Each participant completed a pre- and post- pain induction task and provided a pain rating. All participants completed the same procedures during the pre-test. Only during the post-test did participants in the intervention arms (placebo, non-deceptive) receive additional instructions prior to the pain induction task (i.e., placebo or non-deceptive placebo ratings).

Data coding:

- ID: Contains participant ID number, a letter to indicate group, and pre or post tags. 

  C = Control
  P = Placebo
  N = Non-deceptive
  
- LOCATION: Research Site

- PAIN RATING: Self report of pain based on a 0-10 scale

- DATE: Date of observation


### Question 9

**9A Read in the data.**

To make it slightly more challenging we have changed the format from a .csv to .xlsx and "hidden" the data one level deeper in the /data folder. Take a look at the data to get oriented. Please use "placebo_df" as the name of your data frame.

```{r}
placebo_df <- read_xlsx("data/one_level_deeper/non_deceptive_placebo.xlsx")
```

\newpage

### Question 10

It's a bit difficult to tell what group (control, placebo, or non-deceptive placebo) each participant is in with their IDs combined with their grouping. 

**10A. Create a new column called "GROUP" based on the letter assignment for IDs.**

The stringr function 'str_detect()' will be useful here!

```{r}
placebo_df <- placebo_df %>%
  mutate(
    GROUP = 
        case_when(
          str_starts(ID, regex("c", ignore_case = TRUE)) ~ "Control",
          str_starts(ID, regex("p", ignore_case = TRUE)) ~ "Placebo",
          str_starts(ID, regex("n", ignore_case = TRUE)) ~ "Non-Deceptive",
          TRUE ~ NA_character_
        )
      )
```


**10B. Print the head() of the dataframe** 

```{r}
placebo_df %>% group_by(GROUP) %>% slice_head(n=2)
```

\newpage 

### Question 11

We have a similar issue telling apart the pre- and post- observations. 

**11A. Create a new column called "TEST" that distinguishes whether the observation is a pre- or post-test.**

Unfortunately, the two research sites were not consistent in their naming convention. You will need to consider the different cases. 

```{r}
placebo_df <- placebo_df %>%
  mutate(
    TEST = 
      case_when(
        str_detect(ID, regex("pre", ignore_case = TRUE)) ~ "Pre",
        str_detect(ID, regex("post", ignore_case = TRUE)) ~ "Post",
        TRUE ~ NA_character_
      )
    )
```

**11B. Print the head() of the dataframe** 

```{r}
placebo_df %>% group_by(GROUP, TEST) %>% slice_head(n=1)
```

\newpage 

### Question 12

There were differences in the formatting for dates across the two research sites. 

**12A. Create a new column called "DATE_FIX" that grabs only the date. Make sure this new date column takes the following format: yyyy-mm-dd**

Hint: Check out ?parse_date_time

```{r}
placebo_df <- placebo_df %>%
  mutate(
    DATE_FIX = 
      as.Date(parse_date_time(DATE, c("%b%d%Y", "%d%m%y")), format = "%Y-%m-%d")
    )
```


**12B. Print the head() of the dataframe** 

```{r}
placebo_df %>% group_by(LOCATION) %>% slice_head(n=3)
```


\newpage 

### Question 13

You realize there was a strange error in your excel file that, for every date, pushed the date forward by 1 year. Rather than editing your excel sheet and potentially making an incorrect permanent change to your raw data you decide to fix the error in R. 

**13A. Create a new column called "DATE_FIX_2" that fixes the date.**

```{r}
placebo_df <- placebo_df %>%
  mutate(
    DATE_FIX_2 = as.Date(DATE_FIX - years(x=1)),
    wrng_yr = year(DATE_FIX)
    )
      
placebo_df %>% 
  select(LOCATION, DATE, wrng_yr, DATE_FIX, DATE_FIX_2) %>%
  group_by(LOCATION, wrng_yr) %>% 
  slice_head(n=1)
```

\newpage 

### Question 14

**14A. Clean up the data frame by removing DATE and DATE_FIX.**

**14B. Afterwards, rename DATE_FIX2 to DATE**

```{r}

placebo_df <- placebo_df %>%
  #--14A.
  select(-c(DATE, DATE_FIX, wrng_yr)) %>%
  #--14B.
  rename("DATE" = "DATE_FIX_2") %>%
  relocate(DATE, .before = PAIN_RATE)


```

**14C. Print the head() of the dataframe** 

```{r}
head(placebo_df, 5)
```


\newpage 

### Question 15

We're interested in plotting our data to begin digging into the results. Below is dplyr and ggplot code to do this. 

**15A. Uncomment and run the following code as-is (visualization is not the focus of this problem set).** 

```{r}
 df_plot <- placebo_df %>% 
   group_by(GROUP, LOCATION) %>%
   summarize(MEAN_PAIN = mean(PAIN_RATE))
 
 ggplot(df_plot, aes(x = LOCATION, y = MEAN_PAIN, fill = GROUP)) +
   geom_col(position = "dodge") +
   ylim(0, 10) +
   theme_few() +
   scale_fill_few("Medium") +
   theme(axis.title = element_blank(),
         axis.title.y = element_text()) +
   labs(fill = "Group",
        title = "Non-deceptive placebo study",
        y = "Pain rating")
```


\newpage


For a quick first pass we think this visualization isn't so bad. However, logically, we think that the order of the groups should be: Control, Placebo, Non-deceptive. 

**15B. Make GROUP into a factor that reflects this order.** 

If done correctly, when you re-run the above chunk, the plot should show the bars in that order

```{r}
placebo_df <- placebo_df %>%
  mutate(
    GROUP = 
        factor(
          GROUP, 
          levels = c("Control", "Placebo", "Non-Deceptive"), 
          ordered = TRUE
          )
        )
```

```{r, echo = FALSE}

 df_plot <- placebo_df %>% 
   group_by(GROUP, LOCATION) %>%
   summarize(MEAN_PAIN = mean(PAIN_RATE))
 
 ggplot(df_plot, aes(x = LOCATION, y = MEAN_PAIN, fill = GROUP)) +
   geom_col(position = "dodge") +
   ylim(0, 10) +
   theme_few() +
   scale_fill_few("Medium") +
   theme(axis.title = element_blank(),
         axis.title.y = element_text()) +
   labs(fill = "Group",
        title = "Non-deceptive placebo study",
        y = "Pain rating")
```
